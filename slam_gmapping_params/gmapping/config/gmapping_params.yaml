# http://wiki.ros.org/gmapping

inverted_laser: false # изначально не было (находится ли лазер правой стороной вверх (сканы заказываются против часовой стрелки)
# или вверх ногами (сканы заказываются по часовой стрелке)?)
throttle_scans: 1 # не было (обрабатывать 1 из каждого этого количества сканирований (установите большее число, чтобы пропустить больше сканирований))
base_frame: base_link # (рамка прикреплена к мобильной базе)
map_frame: map # рамка прикреплена к карте
odom_frame: odom # рамка прикреплена к системе одометра
map_update_interval: 0.5 # 2.0 в боте (сколько времени (в секундах) между обновлениями карты. 
# уменьшение этого числа приводит к более частому обновлению сетки заполняемости за счет большей вычислительной нагрузки)
maxUrange: 16.0 # 3.0 в боте (максимальный полезный диапазон лазера. Луч обрезается до этого значения)
sigma: 0.05 # (сигма, используемая жадным сопоставлением конечных точек)
kernelSize: 1 # (размер ядра, в котором нужно искать соответствие)
lstep: 0.05 # (шаг оптимизации в переводе)
astep: 0.05 # (шаг оптимизации в ротации)
iterations: 5 # (количество итераций средства сопоставления сканирования)
lsigma: 0.075 # (сигма луча, используемого для вычисления правдоподобия)
ogain: 3.0 # (усиление, которое будет использоваться при оценке вероятности для сглаживания эффектов передискретизации)
lskip: 0 # (количество лучей, которые необходимо пропустить при каждом сканировании. Возьмите только каждый (n+1)-й лазерный луч для вычисления совпадения (0 = взять все лучи))
minimumScore: 0 # не было изначально (минимальный балл для признания результата сканирования соответствующим хорошему. 
# позволяет избежать скачкообразных оценок позы на больших открытых пространствах при использовании лазерных сканеров с ограниченным радиусом действия (например, 5 м).
# баллы увеличиваются до 600+, попробуйте, например, 50, если возникли проблемы с оценкой прыжков)
srr: 0.1 # (ошибка одометрии при переводе как функция перевода (rho/rho))
srt: 0.2 # (ошибка одометрии при переводе как функция вращения (rho/theta))
str: 0.1 # (ошибка одометрии при вращении как функция перевода (theta/rho))
stt: 0.2 # (ошибка одометрии при вращении как функция вращения (theta/theta))

# сильно влияют на быстродействие
linearUpdate: 1.0 # (обрабатывайте сканирование каждый раз, когда робот переводит так далеко)
angularUpdate: 0.5 # (обрабатывайте сканирование каждый раз, когда робот поворачивается так далеко)
temporalUpdate: 3.0 # 0.5 в боте(выполните сканирование, если последнее обработанное сканирование старше времени обновления в секундах)
# значение меньше нуля отключит обновления, основанные на времени)
resampleThreshold: 0.5 # (порог повторной выборки для фильтра частиц)
particles: 10 # изначально 30 (100 в боте) (очень сильно влияет на быстродействие) (количество частиц в фильтре)
xmin: -10.0 # (начальный размер карты (в метрах) по оси x)
ymin: -10.0 # (начальный размер карты (в метрах) по оси у)
xmax: 10.0 # (начальный размер карты (в метрах) по оси x)
ymax: 10.0 # (начальный размер карты (в метрах) по оси у)

delta: 0.03 # изначально 0.01 (Разрешение карты (в метрах на блок сетки заполняемости))
llsamplerange: 0.01 # (поступательный диапазон выборки для определения вероятности)
llsamplestep: 0.01 # (шаг трансляционной выборки для определения вероятности)
lasamplerange: 0.005 # (угловой диапазон выборки для определения вероятности)
lasamplestep: 0.005 # (угловой шаг выборки для определения вероятности)
transform_publish_period: 0.05 # изначально не было (cколько времени (в секундах) между публикациями преобразования.
# чтобы отключить широковещательные преобразования, установите значение 0)
occ_thresh (float, default: 0.25
maxRange: 17.0 # максимальный радиус действия датчика. если области без препятствий в пределах досягаемости датчика должны отображаться
# на карте как свободное пространство, установите maxURange < максимальный диапазон реального датчика <= maxRange